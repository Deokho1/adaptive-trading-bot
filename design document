0. 문서 목적과 전제
0-1. 이 봇이 하려는 일
이 봇의 목표는 간단히 말해서:
시장 상황에 맞게 전략을 자동으로 바꿔가며 코인을 자동으로 사고파는 것.
조금 풀어서 말하면:
시장 상태를 분석해서
지금이 “추세장(트렌드)”인지
“횡보장(레인지)”인지
아니면 애매해서 건드리면 안 되는 구간인지 판단하고,
상황에 맞는 전략을 자동으로 선택해서 실행한다.
추세장 → 변동성 돌파 전략 (크게 움직일 때 그 방향으로 따라붙기)
횡보장 → RSI 되돌림 전략 (과도하게 눌린 구간에서 되돌림만 먹기)
애매한 구간 → 아무것도 하지 않고 쉰다
이 모든 걸 업비트 Open API를 통해 주문/조회하며,
API 호출 한도(레이트 리밋), 손절, 자본 관리까지 고려해서
**“망하지 않는 봇”**을 목표로 한다.
0-2. 전제 조건
거래소: 업비트
기준 화폐: KRW
봇이 보는 차트: 4시간봉(4H 캔들)
봇이 돌아가는 환경: 미니PC(윈도우든 리눅스든 상관 없음)
언어: 설계 단계라 언급 안 해도 되지만,
나중에 구현은 Python을 기본 상정해도 무방한 구조
1. 기본 개념 설명 (초보자용)
이건 나중에 이 문서를 누가 줏어봐도 이해할 수 있게, 개념부터 짚자.
1-1. 캔들, 특히 4시간봉이 뭐냐
차트에 보이는 하나의 “봉(캔들)”에는 다음 정보가 들어 있다:
시가 (Open): 해당 기간의 시작 가격
고가 (High): 그 기간 동안 가장 비싼 가격
저가 (Low): 그 기간 동안 가장 싼 가격
종가 (Close): 해당 기간이 끝날 때의 가격
거래량 (Volume): 그 기간 동안 얼마나 거래됐는지
이 다섯 개를 합쳐서 흔히 OHLCV라고 부른다.
4시간봉(4H) 은 말 그대로:
“4시간 동안의 가격 움직임을 하나의 캔들로 묶은 것”
하루 24시간 / 4시간 = 하루에 6개의 캔들
우리가 만드는 봇은:
“4시간봉 기준으로 모든 판단을 내리는 봇”이다.
즉, 4시간마다 한 번씩 크게:
시장 상태 분석
전략 실행(진입, 청산 판단)
을 수행한다.
(실시간 손절/익절 체크는 그 사이에도 할 수 있지만,
큰 의사결정 기준은 4시간 단위라고 보면 된다.)
1-2. 우리가 쓰는 주요 지표(인디케이터)
ATR (Average True Range)
역할: **“변동성이 얼마나 큰가”**를 수치로 표현.
쉽게 말해, “최근 N개의 캔들을 보면 평균적으로 얼마나 많이 출렁였냐”를 보는 지표.
생각하기:
ATR이 크다 → 최근에 가격이 쎄게 흔들리고 있다.
ATR이 작다 → 조용하고 움직임이 별로 없다.
우리는 ATR(14) 를 많이 쓸 거다.
(최근 14개 4시간봉 기준 평균 변동폭)
ADX (Average Directional Index)
역할: **“추세의 강도”**를 보는 지표.
0~100 값인데,
25 이상: 보통 추세가 강하다고 본다.
20 이하: 추세 거의 없음 → 횡보 느낌.
중요한 점:
ADX는 “상승 추세냐, 하락 추세냐”가 아니라
“추세가 있냐 없냐(강하냐 약하냐)” 만 말해준다.
Bollinger Band (볼린저 밴드)
가격의 **평균선(중앙선)**을 기준으로,
위쪽으로 일정 거리만큼 떨어진 선: 상단 밴드
아래쪽으로 일정 거리만큼 떨어진 선: 하단 밴드
가격이 상단/하단 밴드를 뚫고 나가면:
상단 돌파 → 과열 혹은 강한 상승
하단 돌파 → 과매도 혹은 강한 하락
우리가 특히 보는 건 밴드 폭(BandWidth) 이다.
BandWidth가 크다 → 밴드가 활짝 벌어짐 = 변동성 큼
BandWidth가 작다 → 밴드가 좁음 = 가격이 좁은 범위에서 왔다갔다 = 횡보 확률 큼
RSI (Relative Strength Index)
역할: **“지금 과열인가, 과매도인가”**를 숫자로 표현.
0~100 사이 숫자:
30 이하: 과매도, “너무 많이 떨어졌다”
70 이상: 과매수, “너무 많이 올랐다”
우리는 RSI(14) 를 기준으로 삼는다.
(최근 14 캔들 기준으로 계산)
ATR_ratio, BandWidth (비율형 지표)
우리는 ATR과 Bollinger Band를 그냥 절대값이 아니라 비율로도 본다.
ATR_ratio:
ATR(14) / 14일 평균가격 * 100
즉 “가격 대비 변동성이 몇 %냐?”.
3% 이상이면 변동성이 꽤 큰 편이다, 이런 식으로 볼 수 있음.
BandWidth:
(볼린저 상단 - 하단) / 중앙선 * 100
밴드가 중앙선 대비 몇 %나 벌어져 있는지.
이 두 개는
변동성이 큰지 / 낮은지,
지금이 트렌드/횡보인지
판단하는 데 중요한 기준으로 사용된다.
1-3. 포지션(Position)이란 뭔가
“내가 어떤 코인을 얼마나 들고 있는가”를 프로그램 입장에서 표현한 객체.
하나의 포지션에는 보통 이런 정보가 필요하다:
어떤 코인인지 (예: BTC/KRW)
얼마나 샀는지 (수량)
얼마에 샀는지 (진입 가격)
언제 샀는지 (시간)
현재 이 포지션은 어떤 전략에 의해 열린 건지
Trend 모드에서 산 건지
Range 모드에서 산 건지
이 포지션이 만들 수 있는 손절/익절 가격
지금까지의 최고가(peak price) — 트레일링 스탑에 필요
우리 봇에서는:
한 코인에 대해 Trend 전략 포지션 1개,
Range 전략 포지션 1개 만 최대 갖는 걸 기본 원칙으로 한다.
(더 간단하게는 코인당 최대 1개 포지션만 허용해도 됨)
2. 전체 시스템 구조 – 큰 틀
이제 큰 그림부터 잡자.
봇은 여러 모듈로 나눠서 설계한다.
각각의 모듈은 역할이 분명해야 나중에 수정/테스트가 쉬워진다.
2-1. 주요 모듈들
UpbitClient
업비트 Open API를 실제로 호출하는 부분.
시세, 캔들, 주문, 잔고 조회 등.
RateLimiter를 안에 품고 있어서,
모든 요청이 한도 내에서 나가도록 통제한다.
DataFetcher
UpbitClient를 사용해서
4시간봉 캔들, 과거 데이터, 현재 가격, 거래량 등을 가져오는 역할.
“데이터를 모으는 역할 전담 모듈”
MarketAnalyzer
DataFetcher가 가져온 BTC 데이터를 기반으로
ATR_ratio, ADX, BandWidth를 계산.
현재 시장 모드를 TREND/RANGE/NEUTRAL 중 하나로 판정.
StrategyManager
MarketAnalyzer가 알려준 모드를 보고
Trend 전략 활성화
Range 전략 활성화
모드 변경 시, 이전 모드의 포지션을 모두 정리(강제 청산).
모드별 가상 자본 한도(Trend 60%, Range 40%)를 관리한다.
Strategies
VolatilityBreakoutStrategy (Trend 모드용)
RSIMeanReversionStrategy (Range 모드용)
각 전략은 “지금 이 상태에서 어떤 주문을 내야 할지”만 결정한다.
예: “BTC 5만원어치 매수”, “ETH 전량 매도”
ExecutionEngine
Strategy가 요구한 주문을 실제로 UpbitClient를 통해 보낸다.
PositionManager를 통해 포지션 상태 업데이트.
RiskManager를 통해 손절/일일 손실/최대 포지션 수 등 제약을 검사.
PositionManager
현재 오픈된 포지션들을 메모리/파일 등으로 관리.
Trend/Range 전략 각각 어디서 얼마에 들어갔는지 저장.
RiskManager
자본 관리:
전체 자본 C
Trend ≤ 0.6C
Range ≤ 0.4C
일일 손실 제한 (Kill Switch)
코인당 최대 비중, 하루 최대 진입 횟수 등.
2-2. 4시간마다 도는 큰 흐름
“4시간봉 기준 한 턴(Loop)”을 시간 흐름으로 보면:
새로운 4시간봉이 마감됨 (예: 12:00, 16:00, 20:00…)
DataFetcher가 BTC/ETH 4H 캔들 및 필요한 데이터 조회
MarketAnalyzer가 시장 모드 계산 (TREND/RANGE/NEUTRAL)
StrategyManager가:
모드 변경 여부 확인
필요하면 이전 모드 포지션 강제 청산
현재 모드에 맞는 전략 실행
각 코인에 대해 전략이
“지금 진입할래 / 아무것도 안 할래 / 이미 들고 있으면 유지할래?” 를 결정
ExecutionEngine이 실제 주문/청산 수행
포지션/잔고/로그 업데이트
이게 4시간마다 반복된다.
그 사이 시간(4시간 중간중간)에는:
손절/트레일링 스탑/RSI 청산 등을 위해
일정 간격(예: 1분, 10초 등)으로 가격을 체크하면서
포지션을 관리할 수 있다.
3. UpbitClient & RateLimiter – API 호출 설계
이제 업비트 Open API를 쓸 때 중요한
**Rate Limit(호출 한도)**를 반영한 설계를 자세히 보자.
3-1. Public vs Private API
Public API
누구나 호출 가능 (API 키 불필요)
시세, 캔들, 호가 등 조회
한도는 비교적 넉넉(대략 초당 10회 정도로 알려짐)
Private API
API Key 필요
내 계정 잔고 조회, 주문/체결 조회, 실제 매수/매도 주문
한도가 더 엄격(대략 초당 3~5회 수준)
우리는 공식 문서의 한도를 항상 확인해야 하지만,
설계 상으로는 한도보다 훨씬 여유 있는 수준으로 요청을 날리는 게 목표다.
3-2. RateLimiter의 역할
RateLimiter는 간단히 말해,
“지금 이 시점에 API를 호출해도 되는지,
아니면 조금 기다렸다가 호출해야 하는지 결정하는 도우미” 다.
내부에 대략 이런 정보를 가진다고 보면 된다:
마지막으로 Public API를 호출한 시간
마지막으로 Private API를 호출한 시간
우리가 허용할 최대 호출 빈도
예: Public: 초당 최대 5회
Private: 초당 최대 2회
동작 개념:
어떤 모듈이 “시세 조회해줘”라고 UpbitClient에 요청한다.
UpbitClient는
“이건 Public API야”라고 RateLimiter에게 알리고
RateLimiter가 “지금 바로 호출해도 괜찮은지”를 판단한다.
만약 “지금 호출하면 안전하다”면 바로 API 요청.
“지금 호출하면 초당 한도 넘을 것 같은데?”면:
RateLimiter가 필요한 만큼 잠깐 sleep (지연) 시킨 뒤 호출.
결과적으로:
어떤 코드든 업비트 API를 직접 칼같이 부르지 않고,
항상 UpbitClient → RateLimiter → 실제 HTTP 요청 순서를 거치게 된다.
3-3. 왜 이런 설계가 필요한가?
만약 우리가 아무 생각 없이:
주문 뒤 체결 체크를 0.1초마다 계속 조회한다거나
캔들을 한 번에 막 20개 코인에 대해 연속 요청한다거나
하면
→ 순식간에 Rate Limit 초과가 나고,
→ 중요한 순간(손절/청산)에도 요청이 막히는 상황이 생길 수 있다.
4시간봉 기반 봇은 어차피 초단타가 아니므로,
“조금 느리더라도 한도 안에서 안전하게 움직이는 것”
이 훨씬 중요하다.
3-4. 설계 상 권장하는 딜레이
Public API (시세, 캔들 조회 등)
연속 호출 시 0.2~0.3초 간격을 두고 호출
Private API (주문, 잔고/주문 조회 등)
주문 상태를 확인하는 반복 조회는
최소 1초 간격 이상으로 설정
가능하면 WebSocket 체결 알림을 활용해서
REST 조회 횟수를 줄이는 것까지 고려
이 정도면 업비트 한도 기준으로 매우 여유로운 수준이다.
4. MarketAnalyzer v2 – 시장 모드 판정 상세
이제 시장 모드를 정하는 핵심 두뇌인 MarketAnalyzer를 자세히 보자.
4-1. 입력과 상태
입력:
BTC의 최근 N개 4시간봉 데이터 (예: 최소 20개 이상)
각 캔들에 대해 계산된 지표:
ATR(14), ADX, Bollinger Band 상단/중앙/하단
내부 상태:
market_mode: 현재 모드 (TREND / RANGE / NEUTRAL)
last_mode_change_time: 마지막으로 모드가 바뀐 시간
4-2. 지표 계산
최근 14개의 BTC 4H 캔들로 ATR(14) 계산
최근 일정 개수 캔들로 ADX 계산
최근 일정 개수 캔들로 볼린저 밴드 계산:
중앙선(평균) / 상단 / 하단
여기서:
ATR_ratio = ATR(14) / 이동평균가격 * 100
BandWidth  = (상단 - 하단) / 중앙선 * 100
이 네 가지 지표:
ADX
ATR_ratio
BandWidth
(비공식으로 MA 기울기 같은 것도 언제든 추가 가능)
를 기반으로 모드를 판정한다.
4-3. TREND 모드 판정
목표: “추세 강도 + 변동성이 모두 충분히 클 때만 TREND로”
TREND 진입 조건(전환 전):
ADX ≥ 25
ATR_ratio ≥ 3.0
→ 여기서 “25”와 “3.0”은 기본값이고,
나중에 백테스트로 조정 가능.
TREND 유지 조건(이미 TREND일 때):
ADX ≥ 22
ATR_ratio ≥ 2.5
→ 진입 때보다 약간 낮춰서
“조금 떨어져도 바로 모드가 바뀌지 않게 버텨주는 역할”
(이게 hysteresis)
4-4. RANGE 모드 판정
목표: “진짜로 좁은 박스권 횡보에서만 RANGE 모드를 쓰자”
RANGE 진입 조건:
ADX ≤ 18 (추세 거의 없음)
BandWidth ≤ 2.0 (밴드 폭이 매우 좁음)
ATR_ratio ≤ 2.0 (변동성도 낮음)
RANGE 유지 조건:
ADX ≤ 22
BandWidth ≤ 2.5
즉:
추세는 약하고
가격은 좁은 범위에서 왔다갔다 하고
전체 변동성도 낮을 때
만 RANGE 모드로 진입한다.
4-5. NEUTRAL 모드
TREND 조건도 아니고 RANGE 조건도 아니면,
그 구간은 NEUTRAL이라고 본다.
의미:
“추세가 있다고 하기도 애매하고, 횡보라고 하기도 애매하다”
이런 구간에서 전략을 실행하면 오히려 털릴 가능성이 크다
그래서:
NEUTRAL 모드에서는 새 포지션 진입을 아예 하지 않는다.
(기존 포지션은 손절/익절 규칙대로 정리)
4-6. Cooldown: 모드 유지 시간
마지막으로 쿨다운 시간이 있다.
모드가 변경되면 last_mode_change_time을 기록.
그 뒤 12시간(3개의 4시간봉) 동안은
웬만해선 모드를 바꾸지 않고 유지한다.
이렇게 하면:
지표가 경계값 근처에서 서성일 때
모드가 계속 TREND↔NEUTRAL↔RANGE 왔다 갔다 하는
**채터링(깜빡거림)**을 막을 수 있다.
5. StrategyManager v2 – 모드 전환·포지션 정책
이제 MarketAnalyzer가 모드를 정하면,
StrategyManager는 그에 맞는 전략을 켜고 끄는 역할을 한다.
5-1. 하는 일
market_mode 확인
모드가 바뀌었는지 체크
바뀌었다면:
이전 모드에서 열린 포지션을 모두 청산
현재 모드에 대응하는 전략을 활성화
모드별 가상 자본 한도 확인
Trend 전략이 이미 0.6C 이상 사용 중이면 신규 진입 금지
Range 전략이 이미 0.4C 이상 사용 중이면 신규 진입 금지
5-2. 모드 ↔ 전략 매핑
TREND   → VolatilityBreakoutStrategy 실행
RANGE   → RSIMeanReversionStrategy 실행
NEUTRAL → 어떤 전략도 신규 진입 없음 (관망)
5-3. 모드 전환 시 강제 청산 정책
이 부분은 아주 명확하게:
TREND → RANGE 또는 NEUTRAL:
TREND 전략 포지션 → 전부 시장가 청산
이유: 돌파 전략은 추세가 죽으면 위험해짐
RANGE → TREND 또는 NEUTRAL:
RANGE 전략 포지션 → 전부 시장가 청산
이유: 역추세 포지션은 새 추세가 시작되면 크게 털릴 수 있음
실제 구현 시 주의점:
“주문만 던져놓고 바로 모드 바꾸기”가 아니라
청산 주문 발행
업비트로부터 체결 완료 응답을 확인
그 다음에 새 모드 전략을 시작하는 게 안전
5-4. 모드별 가상 자본 분리
전체 자본을 C라고 할 때:
TREND 전략에 사용할 수 있는 자본 상한: 0.6 C
RANGE 전략에 사용할 수 있는 자본 상한: 0.4 C
실제로는 계좌가 하나지만,
코드 상에서는 각 전략이 “가상 지갑”을 가진다고 생각하면 편하다.
새 TREND 진입 시:
“만약 이 포지션까지 포함하면 Trend 자본 합계가 0.6C를 넘는가?”
넘으면: 진입 거부
RANGE도 동일.
이렇게 해야 한 전략이 미친 듯이 진입하다가
전체 계좌를 다 쓰는 일을 막을 수 있다.
6. Trend Strategy – Volatility Breakout v2 상세
이제 각 전략 자체를 자세히 보자. 먼저 Trend 모드.
6-1. 목표
“시장이 강하게 어느 한 방향으로 움직일 때 그 방향으로 따라붙어,
추세의 일부를 먹고 적절한 지점에서 나온다.”
6-2. 필요한 데이터
각 코인(BTC, ETH)에 대해:
최근 4시간봉 OHLCV 데이터 (최소 14개 이상)
ATR(14)
최근 종가(prev_close)
현재가(current_price)
현재 4시간봉 거래량(current_volume)
최근 N개(예: 20개) 4시간봉의 평균 거래량(avg_volume)
포지션 정보:
이 코인에 현재 Trend 포지션이 열려 있는지
있으면:
진입가(entry_price)
진입 시간(entry_time)
peak_price(지금까지의 최고가)
수량(size)
6-3. 진입 가격 계산 – ATR 기반
먼저 진입을 고려할 “타겟 가격”을 정한다.
타겟 가격 = 최근 종가 + ATR × 계수
prev_close: 직전 4시간봉 종가
ATR(14): 최근 14개 4시간봉 기준 평균 변동폭
K_ATR: 계수 (예: 0.5 ~ 1.0)
공식:
target_price = prev_close + ATR(14) × K_ATR
이 말은:
“최근 변동폭의 K배만큼 위로 뚫어줄 때 진입하겠다”는 의미.
변동성이 크면 돌파 기준도 크게,
조용할 땐 기준도 작게 조정된다.
6-4. 진입 조건 정리
Trend 모드일 때, 각 코인별로 다음 순서로 체크:
이 코인에 Trend 포지션이 이미 있는지 확인
있으면: 해당 코인은 이 사이클에서는 진입 고려하지 않음
현재가 current_price 가 target_price 이상인가?
아직 돌파 안 했다 → 진입 신호 없음
거래량 필터:
현재 4시간봉의 거래량이
avg_volume × volume_factor 이상인지 확인
volume_factor 기본 1.2 정도
즉, “최근 평균보다 최소 20% 이상 많은 거래량”이 있어야 진입
이걸로 거래량 없는 가짜 돌파를 거른다.
위 3가지 모두 만족하면:
“이 코인, 이번 4시간봉에서 진짜 돌파가 일어났다고 판단 → 진입”
6-5. 포지션 크기(얼마나 살지)
안전하게 시작하기 위한 기본값:
한 번 진입 =
고정 금액 (예: 50,000원) 또는
총자산 C의 5% 중 작은 값
예):
C=1,000,000원 → 5% = 50,000원
→ 5만 원 매수
그리고:
동시에 열 수 있는 Trend 포지션 개수 최대 3개
→ 전체 노출은 약 15% 정도
나중에 전략 성능을 보고:
5%를 7~10%로 조정해볼 수 있다.
6-6. 포지션 진입 시 해야 하는 것
포지션이 새로 열릴 때:
주문 실행 (ExecutionEngine)
체결 결과 확인
PositionManager에 포지션 정보 저장:
symbol: BTC/KRW 등
entry_price: 실제 체결가
entry_time
size(수량)
mode_tag: TREND
peak_price: entry_price로 초기화
6-7. 청산 조건 상세
Trend 포지션은 안전과 효율을 위해 여러 청산 조건을 둔다.
포지션별로 아래를 매 주기(예: 10초~1분 간격) 또는 캔들 마감 시마다 체크한다.
손절 (Hard Stop)
현재가 ≤ entry_price × (1 - 0.03)
→ 대략 -3% 손실
즉시 시장가 청산.
트레일링 스탑 (익절 보호)
포지션을 들고 있는 동안
peak_price = max(peak_price, current_price) 로 갱신.
현재가 ≤ peak_price × (1 - 0.05)
→ 최고점 대비 5% 이상 밀리면 청산.
예: 100 → 130까지 오르다가 123(5% 하락) 되면 청산.
(대략 23% 수익 실현 느낌)
RSI 기반 청산
RSI(14) ≥ 70
이때 포지션이 수익 구간이면
→ “과열 구간”으로 보고 청산.
최대 보유 시간
now - entry_time ≥ 24시간
수익이든 손실이든 일단 정리.
장기 방치 방지.
모드 전환에 의한 강제 청산
MarketAnalyzer가 TREND → RANGE/NEUTRAL 전환
Trend 포지션은 모두 즉시 청산.
청산이 발생하면:
해당 포지션을 PositionManager에서 제거
realized PnL(실현 손익)을 로그/기록
7. Range Strategy – RSI Mean Reversion v2 상세
이제 횡보장용 Range 전략.
7-1. 목표
“가격이 평균에서 너무 벗어나 과매도 구간까지 내려갔을 때,
약간의 되돌림(반등)만 먹고 나오는 단기 역추세 전략.”
7-2. 필요한 데이터
각 코인에 대해:
4시간봉 RSI(14)
4시간봉 Bollinger Band (상단/중앙/하단)
ATR(14)
현재가
과거 가격 (평균/밴드 계산에 사용)
포지션 정보:
이 코인에 Range 포지션이 있는지
있다면 entry_price, entry_time, size, 등
7-3. 진입 조건
Range 모드일 때, 각 코인 별로 아래를 순서대로 확인:
Range 포지션이 이미 있는지
있으면: 해당 코인은 새로 진입 안 함
→ 물타기 금지 전략
RSI 조건:
RSI(14) ≤ 30
→ 현재 과매도 상태
Bollinger Band 조건:
현재가 ≤ 하단 밴드 → 통계적으로 평균보다 꽤 많이 아래로 벗어남
이 세 가지 모두 만족하면:
“너무 많이 눌렸으니, 조금 되돌림이 나올 가능성이 크다 → 소액 진입”
7-4. 포지션 크기
포지션 크기는 Trend보다 약간 보수적으로 잡는다.
한 번 진입 시:
고정 3만 원 혹은
C의 3~5% 정도
모드 전체 한도는 앞에서 말한 것처럼 최대 0.4C까지.
중요한 점:
**추가 진입(물타기)**를 하지 않는다.
이유:
구현이 단순해지고
손실을 예측/계산하기가 쉽다 (리스크가 선형적)
7-5. 포지션 진입 시 해야 하는 작업
Trend와 동일:
주문 실행
체결 확인
PositionManager에 기록:
mode_tag: RANGE
entry_price, entry_time 등
7-6. 청산 조건 상세
Range 포지션은 되돌림이 나왔을 때 가볍게 털고 나오는 게 목표다.
체크 조건:
수익 목표 도달
평가 수익률 ≥ +4%
“짧게 눌린 구간에서 반등 조금 먹고 나가기” 용도
RSI 중립 구간 복귀
RSI(14) ≥ 50
과매도 상태에서 벗어나 “중간 정도”로 돌아온 상태
→ 되돌림이 꽤 나왔다고 보고 청산
손절 – 고정 + ATR 기반
(1) 고정 손절:
fixed_stop = entry_price × 0.98  → 약 -2%
(2) ATR 기반 손절:
atr_stop = entry_price - ATR(14) × N
N은 일반적으로 1.0 정도로 시작
최종 손절 가격:
stop_price = max(fixed_stop, atr_stop)
즉,
고정 -2% 또는 ATR 기반 손절 중 **더 위쪽(덜 손실)**에 있는 가격을 선택.
이렇게 하면 초잡음에 너무 쉽게 나가는 걸 조금 줄이면서도
손실 상한을 확실히 정해둘 수 있다.
모드 전환에 의한 강제 청산
RANGE → TREND/NEUTRAL로 바뀌면
Range 포지션들 전부 시장가 청산.
8. RiskManager – 자본 및 손실 제어
RiskManager는 말 그대로 **“돈 지키는 관리자”**다.
8-1. 자본 한도
전체 자본 C
Trend 전략: 최대 0.6 C
Range 전략: 최대 0.4 C
이 제한을 넘는 신규 진입은 막아야 한다.
8-2. 일일 손실 제한 (Kill Switch)
일 단위(예: 00:00~23:59 기준)로:
오늘 시작(자정) 대비 현재 시점까지의 총 평가손익을 계산한다.
만약 일일 손익률 ≤ -2% 수준까지 떨어지면:
그날 남은 시간 동안 모든 신규 진입을 금지한다.
기존 포지션을:
방어적으로 전부 청산할지,
전략 규칙대로만 정리하게 둘지는 설계에 따라 선택.
보수적 접근:
Kill Switch 발동 시
→ 전체 포지션 시장가 정리
→ 그날은 봇 완전 OFF
8-3. 기타 제약 (선택적)
코인당 최대 비중 (예: 전체 자산의 10% 이상은 한 코인에 몰지 않기)
하루 최대 진입 횟수 (예: Trend+Range 합쳐서 10회)
→ 과한 거래로 수수료만 날리는 것 방지
9. ExecutionEngine – 주문 실행 및 체결 관리
ExecutionEngine은:
“전략이 말한 주문을 실제로 거래소에 보내고, 그 결과를 반영하는 모듈”
이다.
9-1. 주문 흐름
전략이 “BTC 5만 원 시장가 매수” 같은 요청을 만든다.
ExecutionEngine은:
RiskManager에 “이 주문이 자본 한도 내인지” 물어본다.
초과면 주문 거부.
이상 없으면 UpbitClient를 통해 주문 API 호출 (Private API)
주문이 성공적으로 접수되면:
주문 ID 수신
그 주문의 체결 완료를 확인하기 위해 상태 조회
조회 주기는 최소 1초 이상 (RateLimiter 고려)
가능하면 WebSocket 체결 이벤트 사용
체결 정보를 기반으로:
실제 체결 수량, 체결 가격 계산
PositionManager에 새로운 포지션 등록 또는 기존 포지션 수정
9-2. 체결 확인 루프
중요한 점:
주문이 “완전히 체결될 때까지”
너무 자주 상태 조회하면 안 됨 (Private API 한도에 걸림)
따라서:
1초 정도 간격으로 조회하면서
상태: 미체결 → 부분체결 → 완전체결
혹은 WebSocket으로 실시간 알림이 오는 경우:
알림 발생 시에만 REST로 상세 조회
9-3. 에러 및 Rate Limit 초과 처리
에러 예시:
네트워크 오류
HTTP 429 Too Many Requests (호출 한도 초과)
5xx 서버 오류
처리 원칙:
에러 발생 시:
로그에 기록 (시간, 요청 종류, 응답 내용)
Rate Limit 초과(429) 시:
일정 시간(예: 1~2초 이상) 대기 후 재시도
반복 재시도 횟수 제한 (예: 최대 3회)
반복적으로 실패하면:
해당 주문/작업을 실패로 기록하고
RiskManager에 상태 전달 (필요하다면 봇 자체를 잠시 정지)
10. 실제 운용 시나리오 예시 (말로 시뮬레이션)
마지막으로, 머릿속 시뮬레이션을 한 번 해보자.
10-1. 시나리오: 상승장 (TREND 모드)
오전 8시: BTC의 ADX와 ATR_ratio가
TREND 진입 조건(≥25, ≥3.0)을 만족 → MarketAnalyzer: TREND
StrategyManager:
이전엔 NEUTRAL이었으니, 포지션 정리 필요 없음
TREND 모드 활성화
Trend 전략:
BTC, ETH의 target_price 계산
12시 캔들에서 BTC가 target_price 돌파 + 거래량 증가 → BTC 5만 원 매수
오후 내내 BTC가 상승
peak_price 갱신
RSI가 70을 넘고 수익 구간이면
→ 청산, 혹은 트레일링 스탑에 걸려 부분/전체 청산.
10-2. 시나리오: 횡보장 진입 (RANGE 모드)
일주일 후, BTC 변동성이 줄어들고
ADX는 18 이하, BandWidth 2% 이하 → RANGE 진입 조건 만족
MarketAnalyzer: TREND → RANGE 변경
StrategyManager:
TREND 포지션 모두 강제 청산
RANGE 전략 활성화
RANGE 모드에서:
어느 날 RSI가 28, 가격은 볼린저 하단 아래 → Range 전략이 ETH에 3만 원 매수
다음 412시간 동안 RSI가 50 이상으로 회복
→ 수익률 +34% 근처에서 청산
11. 결론
지금까지 정리한 이 설계 문서는:
전략 레벨:
Trend(변동성 돌파) / Range(RSI 역추세) + Adaptive 모드 전환
시스템 레벨:
MarketAnalyzer → StrategyManager → Strategies → Execution
리스크 레벨:
모드별 자본 분리, 손절/트레일링, 일일 손실 한도
인프라 레벨:
업비트 API 한도, RateLimiter, 주문 체결 확인 설계
까지 다 포함하고 있다.
