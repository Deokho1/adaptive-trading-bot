"""
Execution engines for processing TradeSignals in different trading modes.

This module implements the execution layer that consumes TradeSignals
generated by strategies. It supports multiple execution modes:
- PaperExecutionEngine: Simulated trading using real market data
- LiveExecutionEngine: Real trading with actual orders (TODO)
- BacktestExecutionEngine: Historical simulation (TODO)
"""

import logging
from abc import ABC, abstractmethod
from datetime import datetime
from typing import List, Optional, Any

from core.types import MarketMode, OrderSide
from exchange.upbit_client import UpbitClient
from exchange.models import Position
from strategy.base import TradeSignal
from risk.position_manager import PositionManager
from risk.risk_manager import RiskManager


class BaseExecutionEngine(ABC):
    """
    Abstract base class for all execution engines.
    
    Defines the interface that all execution engines must implement.
    """
    
    def __init__(
        self,
        position_manager: PositionManager,
        risk_manager: RiskManager,
    ) -> None:
        """
        Initialize base execution engine.
        
        Args:
            position_manager: Manager for position state
            risk_manager: Manager for risk controls
        """
        self.position_manager = position_manager
        self.risk_manager = risk_manager
        self.logger = logging.getLogger("bot")
    
    @abstractmethod
    def process_signals(
        self,
        signals: List[TradeSignal],
        portfolio_value: float,
        now: datetime,
    ) -> None:
        """
        Process a batch of TradeSignals.
        
        Args:
            signals: List of trade signals to process
            portfolio_value: Current portfolio value in KRW
            now: Current timestamp
        """
        pass
    
    def process_price_tick(self, now: datetime) -> None:
        """
        Process periodic price updates for open positions.
        
        Default implementation does nothing. Subclasses can override.
        
        Args:
            now: Current timestamp
        """
        pass
    
    @abstractmethod
    def get_execution_status(self) -> dict[str, Any]:
        """
        Get current execution engine status.
        
        Returns:
            Dictionary with execution status information
        """
        pass


class PaperExecutionEngine(BaseExecutionEngine):
    """
    Paper trading execution engine.
    
    Simulates order fills using current ticker prices and updates
    PositionManager without placing real orders.
    """
    
    def __init__(
        self,
        upbit_client: UpbitClient,
        position_manager: PositionManager,
        risk_manager: RiskManager,
    ) -> None:
        """
        Initialize PaperExecutionEngine.
        
        Args:
            upbit_client: Client for market data access
            position_manager: Manager for position state
            risk_manager: Manager for risk controls
        """
        super().__init__(position_manager, risk_manager)
        self.client = upbit_client
        
        self.logger.info("PaperExecutionEngine initialized (paper trading mode)")
    
    def __str__(self) -> str:
        """String representation."""
        positions = len(self.position_manager.get_positions())
        return f"PaperExecutionEngine(positions={positions})"
    
    def process_signals(
        self,
        signals: List[TradeSignal],
        portfolio_value: float,
        now: datetime,
    ) -> None:
        """
        Process a batch of TradeSignals.
        
        Args:
            signals: List of trade signals to process
            portfolio_value: Current portfolio value in KRW
            now: Current timestamp
        """
        if not signals:
            self.logger.debug("No signals to process")
            return
        
        self.logger.info(f"Processing {len(signals)} trade signals")
        
        processed_count = 0
        for signal in signals:
            try:
                if signal.side == OrderSide.BUY:
                    success = self._handle_buy(signal, portfolio_value, now)
                elif signal.side == OrderSide.SELL:
                    success = self._handle_sell(signal, portfolio_value, now)
                else:
                    self.logger.warning(f"Unknown signal side: {signal.side}")
                    continue
                
                if success:
                    processed_count += 1
                    
            except Exception as e:
                self.logger.error(f"Error processing signal {signal}: {e}")
        
        # Persist position changes
        self.position_manager.save_positions()
        
        self.logger.info(f"Successfully processed {processed_count}/{len(signals)} signals")
    
    def _handle_buy(
        self,
        signal: TradeSignal,
        portfolio_value: float,
        now: datetime,
    ) -> bool:
        """
        Handle a BUY signal in dry_run mode.
        
        Args:
            signal: Buy signal to process
            portfolio_value: Current portfolio value
            now: Current timestamp
            
        Returns:
            True if order was successfully simulated
        """
        self.logger.info(f"Processing BUY signal: {signal}")
        
        # Check kill switch
        if self.risk_manager.is_kill_switch_active():
            self.logger.warning(f"Kill switch active - skipping BUY {signal.symbol}")
            return False
        
        # Determine order amount
        if signal.amount_krw and signal.amount_krw > 0:
            amount_krw = signal.amount_krw
        else:
            # Default to 1% of portfolio
            amount_krw = portfolio_value * 0.01
            
        self.logger.debug(f"Order amount: {amount_krw:,.0f} KRW")
        
        # Risk checks
        existing_positions = self.position_manager.get_positions()
        
        self.logger.debug(
            f"Risk check: mode={signal.mode}, amount={amount_krw:,.0f}, "
            f"existing_positions={len(existing_positions)}, "
            f"portfolio_value={portfolio_value:,.0f}"
        )
        
        if not self.risk_manager.can_open_trade(
            signal.mode,
            portfolio_value,
            existing_positions,
            amount_krw,
            signal.symbol,
        ):
            self.logger.warning(f"Risk manager rejected trade for {signal.symbol}")
            return False
        
        # Get current market price
        try:
            price = self.client.get_ticker_price(signal.symbol)
        except Exception as e:
            self.logger.error(f"Failed to get ticker price for {signal.symbol}: {e}")
            return False
        
        if price <= 0:
            self.logger.error(f"Invalid price for {signal.symbol}: {price}")
            return False
        
        # Calculate position size
        size = amount_krw / price
        
        # Simulate order execution
        try:
            self.position_manager.open_position(
                symbol=signal.symbol,
                mode=signal.mode,
                entry_price=price,
                size=size,
                now=now
            )
            
            self.logger.info(
                f"ðŸ“ˆ SIMULATED BUY: {signal.symbol} "
                f"@ {price:,.0f} KRW, "
                f"size={size:.6f}, "
                f"value={amount_krw:,.0f} KRW, "
                f"reason={signal.reason}"
            )
            
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to open position for {signal.symbol}: {e}")
            return False
    
    def _handle_sell(
        self,
        signal: TradeSignal,
        portfolio_value: float,
        now: datetime,
    ) -> bool:
        """
        Handle a SELL signal in dry_run mode.
        
        Args:
            signal: Sell signal to process
            portfolio_value: Current portfolio value
            now: Current timestamp
            
        Returns:
            True if order was successfully simulated
        """
        self.logger.info(f"Processing SELL signal: {signal}")
        
        # Find existing position
        position = self.position_manager.get_position(signal.symbol)
        if position is None:
            self.logger.warning(f"No position found for {signal.symbol} - skipping SELL")
            return False
        
        # Get current market price
        try:
            price = self.client.get_ticker_price(signal.symbol)
        except Exception as e:
            self.logger.error(f"Failed to get ticker price for {signal.symbol}: {e}")
            return False
        
        if price <= 0:
            self.logger.error(f"Invalid price for {signal.symbol}: {price}")
            return False
        
        # Calculate P&L
        pnl_krw = (price - position.entry_price) * position.size
        pnl_pct = ((price - position.entry_price) / position.entry_price) * 100
        
        # Simulate order execution
        try:
            self.position_manager.close_position(signal.symbol)
            
            self.logger.info(
                f"ðŸ“‰ SIMULATED SELL: {signal.symbol} "
                f"@ {price:,.0f} KRW, "
                f"size={position.size:.6f}, "
                f"PnL={pnl_krw:+,.0f} KRW ({pnl_pct:+.2f}%), "
                f"reason={signal.reason}"
            )
            
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to close position for {signal.symbol}: {e}")
            return False
    
    def process_price_tick(self, now: datetime) -> None:
        """
        Process periodic price updates for open positions.
        
        Updates peak prices for trailing stop calculations and
        other time-based position management logic.
        
        Args:
            now: Current timestamp
        """
        positions = self.position_manager.get_positions()
        
        if not positions:
            return
        
        self.logger.debug(f"Processing price tick for {len(positions)} positions")
        
        updated_count = 0
        
        for position in positions:
            try:
                # Get current price
                current_price = self.client.get_ticker_price(position.symbol)
                
                if current_price <= 0:
                    self.logger.warning(f"Invalid price for {position.symbol}: {current_price}")
                    continue
                
                # Update peak price if current price is higher
                if current_price > position.peak_price:
                    old_peak = position.peak_price
                    position.peak_price = current_price
                    updated_count += 1
                    
                    self.logger.debug(
                        f"Updated peak price for {position.symbol}: "
                        f"{old_peak:,.0f} -> {current_price:,.0f}"
                    )
                
            except Exception as e:
                self.logger.error(f"Error updating price for {position.symbol}: {e}")
        
        if updated_count > 0:
            # Save updated positions
            self.position_manager.save_positions()
            self.logger.debug(f"Updated peak prices for {updated_count} positions")
    
    def get_execution_status(self) -> dict:
        """
        Get current execution engine status.
        
        Returns:
            Dictionary with execution status information
        """
        positions = self.position_manager.get_positions()
        
        # Calculate total exposure
        total_exposure = 0.0
        for position in positions:
            try:
                current_price = self.client.get_ticker_price(position.symbol)
                if current_price > 0:
                    total_exposure += current_price * position.size
            except Exception:
                # Use entry price as fallback
                total_exposure += position.entry_price * position.size
        
        return {
            "mode": "paper",
            "total_positions": len(positions),
            "total_exposure_krw": total_exposure,
            "kill_switch_active": self.risk_manager.is_kill_switch_active(),
            "positions": [
                {
                    "symbol": pos.symbol,
                    "mode": pos.mode.name,
                    "entry_price": pos.entry_price,
                    "peak_price": pos.peak_price,
                    "size": pos.size,
                    "entry_time": pos.entry_time.isoformat(),
                }
                for pos in positions
            ],
        }


class LiveExecutionEngine(BaseExecutionEngine):
    """
    Live trading execution engine.
    
    This engine will implement real trading using Upbit private API
    to place actual orders with real money. Currently not implemented.
    """
    
    def __init__(
        self,
        upbit_client: UpbitClient,
        position_manager: PositionManager,
        risk_manager: RiskManager,
    ) -> None:
        """
        Initialize LiveExecutionEngine.
        
        Args:
            upbit_client: Client for market data access and order placement
            position_manager: Manager for position state
            risk_manager: Manager for risk controls
        """
        super().__init__(position_manager, risk_manager)
        self.client = upbit_client
        
        self.logger.warning("LiveExecutionEngine initialized - REAL TRADING MODE")
        self.logger.warning("This engine is not implemented yet and will raise errors!")
    
    def __str__(self) -> str:
        """String representation."""
        positions = len(self.position_manager.get_positions())
        return f"LiveExecutionEngine(positions={positions}) [NOT IMPLEMENTED]"
    
    def process_signals(
        self,
        signals: List[TradeSignal],
        portfolio_value: float,
        now: datetime,
    ) -> None:
        """
        Process trading signals with real orders.
        
        TODO: Implement real order placement using Upbit private API.
        """
        raise NotImplementedError(
            "LiveExecutionEngine is not implemented yet. "
            "Real trading functionality requires Upbit private API integration."
        )
    
    def get_execution_status(self) -> dict[str, Any]:
        """Get execution status for live trading."""
        return {
            "mode": "live",
            "implemented": False,
            "error": "LiveExecutionEngine not implemented yet",
        }


class BacktestExecutionEngine(BaseExecutionEngine):
    """
    Backtesting execution engine.
    
    This engine will implement historical simulation using past market data
    to test trading strategies. Currently not implemented.
    """
    
    def __init__(
        self,
        position_manager: PositionManager,
        risk_manager: RiskManager,
    ) -> None:
        """
        Initialize BacktestExecutionEngine.
        
        Args:
            position_manager: Manager for position state
            risk_manager: Manager for risk controls
        """
        super().__init__(position_manager, risk_manager)
        
        self.logger.info("BacktestExecutionEngine initialized - BACKTESTING MODE")
        self.logger.warning("This engine is not implemented yet and will raise errors!")
    
    def __str__(self) -> str:
        """String representation."""
        positions = len(self.position_manager.get_positions())
        return f"BacktestExecutionEngine(positions={positions}) [NOT IMPLEMENTED]"
    
    def process_signals(
        self,
        signals: List[TradeSignal],
        portfolio_value: float,
        now: datetime,
    ) -> None:
        """
        Process trading signals in backtest simulation.
        
        TODO: Implement backtesting logic using historical data.
        """
        raise NotImplementedError(
            "BacktestExecutionEngine is not implemented yet. "
            "Backtesting functionality should be handled by a separate BacktestRunner."
        )
    
    def get_execution_status(self) -> dict[str, Any]:
        """Get execution status for backtesting."""
        return {
            "mode": "backtest",
            "implemented": False,
            "error": "BacktestExecutionEngine not implemented yet",
        }