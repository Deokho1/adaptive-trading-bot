"""
Base classes and data structures for trading strategies.

This module defines the core interfaces and data structures
that all trading strategies must implement.
"""

from dataclasses import dataclass
from datetime import datetime
from typing import Any, List

from core.types import MarketMode, OrderSide
from exchange.models import Candle, Position


@dataclass
class StrategyContext:
    """
    Context information provided to strategies for decision making.
    
    Contains all the information a strategy needs to generate trading signals,
    including market data, indicators, current position, and portfolio status.
    """
    symbol: str                    # Trading pair (e.g., "KRW-BTC")
    candles: List[Candle]         # Historical candle data
    indicators: dict[str, Any]     # Technical indicators {"atr": ..., "rsi": ..., "bbands": {...}}
    mode: MarketMode              # Current market mode (TREND/RANGE/NEUTRAL)
    position: Position | None     # Current position for this symbol (if any)
    portfolio_value: float        # Total portfolio value in KRW
    available_krw: float          # Available KRW for new positions
    now: datetime                 # Current timestamp


@dataclass
class TradeSignal:
    """
    A trading signal generated by a strategy.
    
    Represents a recommendation to buy or sell a particular symbol
    with specific parameters and reasoning.
    """
    symbol: str                   # Trading pair
    side: OrderSide              # BUY or SELL
    mode: MarketMode             # Market mode when signal was generated
    reason: str                  # Human-readable explanation for the signal
    amount_krw: float | None = None  # KRW amount for BUY orders
    size: float | None = None        # Cryptocurrency size for SELL orders
    
    def __str__(self) -> str:
        if self.side == OrderSide.BUY and self.amount_krw:
            return f"TradeSignal({self.side} {self.symbol} {self.amount_krw:,.0f} KRW in {self.mode} mode: {self.reason})"
        elif self.side == OrderSide.SELL and self.size:
            return f"TradeSignal({self.side} {self.symbol} {self.size:.6f} coins in {self.mode} mode: {self.reason})"
        else:
            return f"TradeSignal({self.side} {self.symbol} in {self.mode} mode: {self.reason})"
    
    def __repr__(self) -> str:
        return self.__str__()


class Strategy:
    """
    Base class for all trading strategies.
    
    Subclasses should implement generate_signals() to provide specific
    trading logic for different market modes (trend-following, mean-reversion, etc.).
    """
    
    def __init__(self, config: dict) -> None:
        """
        Initialize the strategy with configuration.
        
        Args:
            config: Strategy configuration dictionary
        """
        self.config = config
        self.name = self.__class__.__name__
    
    def generate_signals(self, context: StrategyContext) -> List[TradeSignal]:
        """
        Generate trading signals based on the provided context.
        
        This method should be overridden by concrete strategy implementations
        to provide specific trading logic.
        
        Args:
            context: StrategyContext containing market data and portfolio info
        
        Returns:
            List of TradeSignal objects (can be empty if no signals)
        
        Raises:
            NotImplementedError: If not overridden by subclass
        """
        raise NotImplementedError(f"{self.name} must implement generate_signals()")
    
    def __str__(self) -> str:
        return f"{self.name}(config_keys={list(self.config.keys())})"
    
    def __repr__(self) -> str:
        return self.__str__()